#!/usr/bin/python
import numpy as np
from scipy import ndimage
import math

def get_line(x1, y1, x2, y2):
	x1=int(x1)
	y1=int(y1)
	x2=int(x2)
	y2=int(y2)
	points = []
    	issteep = abs(y2-y1) > abs(x2-x1)
   	if issteep:
        	x1, y1 = y1, x1
        	x2, y2 = y2, x2
    	rev = False
    	if x1 > x2:
        	x1, x2 = x2, x1
        	y1, y2 = y2, y1
        	rev = True
    	deltax = x2 - x1
    	deltay = abs(y2-y1)
    	error = int(deltax / 2)
    	y = y1
    	ystep = None
    	if y1 < y2:
        	ystep = 1
    	else:
        	ystep = -1
    	for x in range(x1, x2 + 1):
        	if issteep:
            		points.append((y, x))
       		else:
            		points.append((x, y))
        	error -= deltay
        	if error < 0:
            		y += ystep
            		error += deltax
    # Reverse the list if the coordinates were reversed
    	if rev:
        	points.reverse()
    	return points

def get_distance(x1, y1, x2, y2):
	return math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))

def get_outline_mask(p, rows, cols):
	s1=p.split('(')
	x=[]
	y=[]
	for i in xrange(1, len(s1)):
		s2=s1[i].split(')')
		s3=s2[0].split(',')
		x.append(float(s3[0]))
		y.append(float(s3[1]))
		
	
	for c in xrange(len(x)):
		x[c]=round(x[c])
		y[c]=round(y[c])
		if x[c]<0:
			x[c]=0
		if y[c]<0:
			y[c]=0
		if x[c]>=cols:
			x[c]=cols-1
		if y[c]>=rows:
			y[c]=rows-1

		  	
	x_add=[]
	y_add=[]


	for i in xrange(len(x)-1):
		if get_distance(x[i], y[i], x[i+1], y[i+1])>1.4142:
			line = get_line(x[i], y[i], x[i+1], y[i+1])
			if len(line)>2:
				for j in xrange(1,len(line)):
					x_add.append(line[j][0])
					y_add.append(line[j][1])

	if get_distance(x[0], y[0], x[len(x)-1], y[len(y)-1])>1.4142:
		line = get_line(x[0], y[0], x[len(x)-1], y[len(x)-1])
		x2 = [line[i][0] for i in xrange(1, len(line)-1)]
		y2 = [line[i][1] for i in xrange(1, len(line)-1)]
		for i in xrange(len(x2)):
			x.append(x2[i])
			y.append(y2[i])

	
	img=np.zeros((rows, cols))
	
	for i in xrange(len(x)):
		img[y[i], x[i]]=1
	
	for i in xrange(len(x_add)):
		img[y_add[i], x_add[i]]=1
	
	for i in xrange(rows):
		for j in xrange(cols):
			
			if img[i, j]==0:
				neighors1=[]
				neighors2=[]
				neighors3=[]
				neighors1.append((i-1, j-1))
				neighors1.append((i-1, j))
				neighors1.append((i-1, j+1))
				neighors3.append((i, j-1))
				neighors3.append((i, j+1))
				neighors2.append((i+1, j-1))
				neighors2.append((i+1, j))
				neighors2.append((i+1, j+1))
				flag1=0
				flag2=0
				flag3=0
				for n in neighors1:
					k=n[0]
					l=n[1]
				
					if k>=0 and k<rows and l>=0 and l<cols:
						if img[k, l]==1:
							#print flag
							flag1=flag1+1
				for n in neighors2:
					k=n[0]
					l=n[1]
					if k>=0 and k<rows and l>=0 and l<cols:
						if img[k, l]==1:
							flag2=flag2+1
				for n in neighors3:
					k=n[0]
					l=n[1]
					if k>=0 and k<rows and l>=0 and l<cols:
						if img[k, l]==1:
							flag3=flag3+1

				if (flag1>1 and flag2>1) or flag3==2:
					img[i, j] = 1					


		
	return img


def rasterize(img):
	return ndimage.binary_fill_holes(img).astype(np.uint8)

def mean_pixel_value(img, mask):
	assert(np.array_equal(img.shape, mask.shape)==True)
	
	newimg=np.zeros(img.shape)
	
	for i in xrange(img.shape[0]):
		for j in xrange(img.shape[1]):
			if mask[i, j]==1:
				newimg[i,j]=img[i,j]
	
	return np.mean(newimg)

def std_dev_pixel_value(img, mask):
	assert(np.arry_equal(img.shape, mask.shape)==True)

	newimg=np.zeros(img.shape)

	for i in xrange(img.shape[0]):
		for j in xrange(img.shape[1]):
			if mask[i, j]==1:
				newimg[i, j]=img[i, j]
	return np.std(newimg)

def effective_diameter(mask):
	area=np.sum(mask)
	d=math.sqrt(area/math.pi)
	return d	


if __name__=='__main__':
	import sys
	img=get_outline_mask(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))
	print np.array_equal(img.astype(np.uint8), rasterize(img))
	
	
