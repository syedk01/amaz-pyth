#!/usr/bin/python
import numpy as np
from scipy import ndimage
from scipy.ndimage import measurements
import math
from numpy import matlib, dtype
from numpy.linalg import eig, inv

def get_line(x1, y1, x2, y2):
	x1=int(x1)
	y1=int(y1)
	x2=int(x2)
	y2=int(y2)
	points = []
    	issteep = abs(y2-y1) > abs(x2-x1)
   	if issteep:
        	x1, y1 = y1, x1
        	x2, y2 = y2, x2
    	rev = False
    	if x1 > x2:
        	x1, x2 = x2, x1
        	y1, y2 = y2, y1
        	rev = True
    	deltax = x2 - x1
    	deltay = abs(y2-y1)
    	error = int(deltax / 2)
    	y = y1
    	ystep = None
    	if y1 < y2:
        	ystep = 1
    	else:
        	ystep = -1
    	for x in range(x1, x2 + 1):
        	if issteep:
            		points.append((y, x))
       		else:
            		points.append((x, y))
        	error -= deltay
        	if error < 0:
            		y += ystep
            		error += deltax
    # Reverse the list if the coordinates were reversed
    	if rev:
        	points.reverse()
    	return points

def fit_ellipse(x,y):
    x = x[:,np.newaxis]
    y = y[:,np.newaxis]
    D =  np.hstack((x*x, x*y, y*y, x, y, np.ones_like(x)))
    S = np.dot(D.T,D)
    C = np.zeros([6,6])
    C[0,2] = C[2,0] = 2; C[1,1] = -1
    E, V =  eig(np.dot(inv(S), C))
    n = np.argmax(np.abs(E))
    a = V[:,n]
    return a

def ellipse_center(a):
    b,c,d,f,g,a = a[1]/2, a[2], a[3]/2, a[4]/2, a[5], a[0]
    num = b*b-a*c
    x0=(c*d-b*f)/num
    y0=(a*f-b*d)/num
    return np.array([x0,y0])

def ellipse_angle_of_rotation( a ):
    b,c,d,f,g,a = a[1]/2, a[2], a[3]/2, a[4]/2, a[5], a[0]
    return 0.5*np.arctan(2*b/(a-c))

def ellipse_axis_length( a ):
    b,c,d,f,g,a = a[1]/2, a[2], a[3]/2, a[4]/2, a[5], a[0]
    up = 2*(a*f*f+c*d*d+g*b*b-2*b*d*f-a*c*g)
    down1=(b*b-a*c)*( (c-a)*np.sqrt(1+4*b*b/((a-c)*(a-c)))-(c+a))
    down2=(b*b-a*c)*( (a-c)*np.sqrt(1+4*b*b/((a-c)*(a-c)))-(c+a))
    res1=np.sqrt(up/down1)
    res2=np.sqrt(up/down2)
    return np.array([res1, res2])

def get_distance(x1, y1, x2, y2):
	return math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))

def get_outline_mask(p, rows, cols):
	s1=p.split('(')
	x=[]
	y=[]
	for i in xrange(1, len(s1)):
		s2=s1[i].split(')')
		s3=s2[0].split(',')
		x.append(float(s3[0]))
		y.append(float(s3[1]))
		
	
	for c in xrange(len(x)):
		x[c]=round(x[c])
		y[c]=round(y[c])
		if x[c]<0:
			x[c]=0
		if y[c]<0:
			y[c]=0
		if x[c]>=cols:
			x[c]=cols-1
		if y[c]>=rows:
			y[c]=rows-1

		  	
	x_add=[]
	y_add=[]


	for i in xrange(len(x)-1):
		if get_distance(x[i], y[i], x[i+1], y[i+1])>1.4142:
			line = get_line(x[i], y[i], x[i+1], y[i+1])
			if len(line)>2:
				for j in xrange(1,len(line)):
					x_add.append(line[j][0])
					y_add.append(line[j][1])

	if get_distance(x[0], y[0], x[len(x)-1], y[len(y)-1])>1.4142:
		line = get_line(x[0], y[0], x[len(x)-1], y[len(x)-1])
		x2 = [line[i][0] for i in xrange(1, len(line)-1)]
		y2 = [line[i][1] for i in xrange(1, len(line)-1)]
		for i in xrange(len(x2)):
			x.append(x2[i])
			y.append(y2[i])

	
	img=np.zeros((rows, cols))
	
	for i in xrange(len(x)):
		img[y[i], x[i]]=1
	
	for i in xrange(len(x_add)):
		img[y_add[i], x_add[i]]=1
	
	for i in xrange(rows):
		for j in xrange(cols):
			
			if img[i, j]==0:
				neighors1=[]
				neighors2=[]
				neighors3=[]
				neighors1.append((i-1, j-1))
				neighors1.append((i-1, j))
				neighors1.append((i-1, j+1))
				neighors3.append((i, j-1))
				neighors3.append((i, j+1))
				neighors2.append((i+1, j-1))
				neighors2.append((i+1, j))
				neighors2.append((i+1, j+1))
				flag1=0
				flag2=0
				flag3=0
				for n in neighors1:
					k=n[0]
					l=n[1]
				
					if k>=0 and k<rows and l>=0 and l<cols:
						if img[k, l]==1:
							#print flag
							flag1=flag1+1
				for n in neighors2:
					k=n[0]
					l=n[1]
					if k>=0 and k<rows and l>=0 and l<cols:
						if img[k, l]==1:
							flag2=flag2+1
				for n in neighors3:
					k=n[0]
					l=n[1]
					if k>=0 and k<rows and l>=0 and l<cols:
						if img[k, l]==1:
							flag3=flag3+1

				if (flag1>=1 and flag2>=1) or flag3==2:
					img[i, j] = 1					


		
	return rasterize(img).astype(np.uint)


def rasterize(img):
	return ndimage.binary_fill_holes(img).astype(np.uint8)
def mean_pixel_value(img, mask):
        assert(np.array_equal(img.shape, mask.shape)==True)

        newimg=np.zeros(img.shape)

        for i in xrange(img.shape[0]):
                for j in xrange(img.shape[1]):
                        if mask[i, j]==1:
                                newimg[i,j]=img[i,j]

        return np.mean(newimg)

def std_dev_pixel_value(img, mask):
        assert(np.arry_equal(img.shape, mask.shape)==True)

        newimg=np.zeros(img.shape)

        for i in xrange(img.shape[0]):
                for j in xrange(img.shape[1]):
                        if mask[i, j]==1:
                                newimg[i, j]=img[i, j]
        return np.std(newimg)

def effective_diameter(mask):
        area=np.sum(mask)
        d=math.sqrt(area/math.pi)
        return d

def degree_of_circularity(mask):
	centroids = ndimage.measurements.center_of_mass(mask)
	x = 0
	y = 0
	if type(centroids)==type([]):
		x = np.mean(np.array([pt[0] for pt in centroids]))
		y = np.mean(np.array([pt[1] for pt in centroids]))
	else:
		x = centroids[0]
		y = centroids[1]
	
	
	diameter = effective_diameter(mask)
#	MatX = np.matlib.repmat(np.array([e-x for e in  xrange(mask.shape[1])]), mask.shape[0], 1)
#	MatY = np.matlib.repmat(np.transpose(np.array([e-y for e in xrange(mask.shape[0])])), 1, mask.shape[1])
	XY = np.empty(mask.shape, object)

	for i in xrange(mask.shape[0]):
		for j in xrange(mask.shape[1]):
			XY[i, j] = (j-x, i-y)
	
	Z=np.zeros(mask.shape)
		
	for i in xrange(Z.shape[0]):
		for j in xrange(Z.shape[1]):
			Z[i, j] = XY[i, j][0]**2 + XY[i, j][1]**2
			
	C=np.zeros(mask.shape)
	
	for i in xrange(Z.shape[0]):
		for j in xrange(Z.shape[1]):
			if Z[i, j] <= (diameter*diameter):
				C[i, j] = 1
 	
	C = rasterize(C).astype(np.uint)
	nodule_area = np.sum(mask)
	overlapping_nodule_area = np.sum(np.logical_and(C, rasterize(mask).astype(np.uint)).astype(int))
	
	return overlapping_nodule_area/nodule_area

def degree_of_ellipticity(mask):
	pts = np.nonzero(mask)
	#print pts	
	a  = fit_ellipse(np.array([pts[1][i] for i in xrange(pts[1].shape[0])]), np.array([pts[0][i] for i in xrange(pts[0].shape[0])]))
	center = ellipse_center(a)
	alpha = ellipse_angle_of_rotation(a)
	axes = ellipse_axis_length(a)
	
	t = np.linspace(0, 2*math.pi, mask.shape[0])
	Q = np.array([[math.cos(alpha), -math.sin(alpha)], [math.sin(alpha), math.cos(alpha)]])
	
	tarr = np.empty((1, 2)) 
	
	for i in xrange(t.shape[0]):
		tarr = np.vstack((tarr, [axes[0]*math.cos(t[i]), axes[1]*math.sin(t[i])]))
	
	tarr =np.transpose(tarr)
	
	z = np.empty((1, 2))

        for i in xrange(t.shape[0]):
                z = np.vstack((z, [center[0], center[1]]))
	
	z=np.transpose(z)
	
	X = np.transpose(np.dot(Q, tarr) + z).astype(int)

	E = np.zeros(mask.shape)
	
	for i in xrange(X.shape[0]):
		if X[i, 1]>=0 and X[i, 1]<mask.shape[0] and X[i, 0]>=0 and X[i, 0]<mask.shape[1]:
			E[X[i, 1], X[i, 0]] = 1

	E = rasterize(E).astype(np.uint)
	
        nodule_area = np.sum(mask)
        overlapping_nodule_area = np.sum(np.logical_and(E, rasterize(mask).astype(np.uint)).astype(int))

        return overlapping_nodule_area/nodule_area
	
def marginal_irregularity:

        pts = np.nonzero(mask)
        #print pts
        a  = fit_ellipse(np.array([pts[1][i] for i in xrange(pts[1].shape[0])]), np.array([pts[0][i] for i in xrange(pts[0].shape[0])]))
        center = ellipse_center(a)
        alpha = ellipse_angle_of_rotation(a)
        axes = ellipse_axis_length(a)

        t = np.linspace(0, 2*math.pi, mask.shape[0])
        Q = np.array([[math.cos(alpha), -math.sin(alpha)], [math.sin(alpha), math.cos(alpha)]])

        tarr = np.empty((1, 2))

        for i in xrange(t.shape[0]):
                tarr = np.vstack((tarr, [axes[0]*math.cos(t[i]), axes[1]*math.sin(t[i])]))

        tarr =np.transpose(tarr)

        z = np.empty((1, 2))

        for i in xrange(t.shape[0]):
                z = np.vstack((z, [center[0], center[1]]))

        z=np.transpose(z)

        X = np.transpose(np.dot(Q, tarr) + z).astype(int)

        E = np.zeros(mask.shape)

        for i in xrange(X.shape[0]):
                if X[i, 1]>=0 and X[i, 1]<mask.shape[0] and X[i, 0]>=0 and X[i, 0]<mask.shape[1]:
                        E[X[i, 1], X[i, 0]] = 1

        pts1 = np.nonzeros(E)
	pt_e = np.array([[pts1[0][i], pts1[1][i]] for i in xrange(pts1[0].shape[0])])
	degree_of_irregularity = 1 - pts[0].shape[0]/pts1[0].shape[0]

	d = np.zeros(pts[1].shape[0], 1)
	
	
	
	for i in xrange(pts[0].shape):
		point = np.array([])
	
if __name__=='__main__':
	import sys
	img=get_outline_mask(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))
	#print np.array_equal(img.astype(np.uint8), rasterize(img))
	print degree_of_ellipticity(rasterize(img))
