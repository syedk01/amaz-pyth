#!/usr/bin/python
import numpy as np
from scipy import ndimage
from scipy.ndimage import measurements
import math
from numpy import matlib

def get_line(x1, y1, x2, y2):
	x1=int(x1)
	y1=int(y1)
	x2=int(x2)
	y2=int(y2)
	points = []
    	issteep = abs(y2-y1) > abs(x2-x1)
   	if issteep:
        	x1, y1 = y1, x1
        	x2, y2 = y2, x2
    	rev = False
    	if x1 > x2:
        	x1, x2 = x2, x1
        	y1, y2 = y2, y1
        	rev = True
    	deltax = x2 - x1
    	deltay = abs(y2-y1)
    	error = int(deltax / 2)
    	y = y1
    	ystep = None
    	if y1 < y2:
        	ystep = 1
    	else:
        	ystep = -1
    	for x in range(x1, x2 + 1):
        	if issteep:
            		points.append((y, x))
       		else:
            		points.append((x, y))
        	error -= deltay
        	if error < 0:
            		y += ystep
            		error += deltax
    # Reverse the list if the coordinates were reversed
    	if rev:
        	points.reverse()
    	return points

def get_distance(x1, y1, x2, y2):
	return math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))

def get_outline_mask(p, rows, cols):
	s1=p.split('(')
	x=[]
	y=[]
	for i in xrange(1, len(s1)):
		s2=s1[i].split(')')
		s3=s2[0].split(',')
		x.append(float(s3[0]))
		y.append(float(s3[1]))
		
	
	for c in xrange(len(x)):
		x[c]=round(x[c])
		y[c]=round(y[c])
		if x[c]<0:
			x[c]=0
		if y[c]<0:
			y[c]=0
		if x[c]>=cols:
			x[c]=cols-1
		if y[c]>=rows:
			y[c]=rows-1

		  	
	x_add=[]
	y_add=[]


	for i in xrange(len(x)-1):
		if get_distance(x[i], y[i], x[i+1], y[i+1])>1.4142:
			line = get_line(x[i], y[i], x[i+1], y[i+1])
			if len(line)>2:
				for j in xrange(1,len(line)):
					x_add.append(line[j][0])
					y_add.append(line[j][1])

	if get_distance(x[0], y[0], x[len(x)-1], y[len(y)-1])>1.4142:
		line = get_line(x[0], y[0], x[len(x)-1], y[len(x)-1])
		x2 = [line[i][0] for i in xrange(1, len(line)-1)]
		y2 = [line[i][1] for i in xrange(1, len(line)-1)]
		for i in xrange(len(x2)):
			x.append(x2[i])
			y.append(y2[i])

	
	img=np.zeros((rows, cols))
	
	for i in xrange(len(x)):
		img[y[i], x[i]]=1
	
	for i in xrange(len(x_add)):
		img[y_add[i], x_add[i]]=1
	
	for i in xrange(rows):
		for j in xrange(cols):
			
			if img[i, j]==0:
				neighors1=[]
				neighors2=[]
				neighors3=[]
				neighors1.append((i-1, j-1))
				neighors1.append((i-1, j))
				neighors1.append((i-1, j+1))
				neighors3.append((i, j-1))
				neighors3.append((i, j+1))
				neighors2.append((i+1, j-1))
				neighors2.append((i+1, j))
				neighors2.append((i+1, j+1))
				flag1=0
				flag2=0
				flag3=0
				for n in neighors1:
					k=n[0]
					l=n[1]
				
					if k>=0 and k<rows and l>=0 and l<cols:
						if img[k, l]==1:
							#print flag
							flag1=flag1+1
				for n in neighors2:
					k=n[0]
					l=n[1]
					if k>=0 and k<rows and l>=0 and l<cols:
						if img[k, l]==1:
							flag2=flag2+1
				for n in neighors3:
					k=n[0]
					l=n[1]
					if k>=0 and k<rows and l>=0 and l<cols:
						if img[k, l]==1:
							flag3=flag3+1

				if (flag1>1 and flag2>1) or flag3==2:
					img[i, j] = 1					


		
	return img


def rasterize(img):
	return ndimage.binary_fill_holes(img).astype(np.uint8)
def mean_pixel_value(img, mask):
        assert(np.array_equal(img.shape, mask.shape)==True)

        newimg=np.zeros(img.shape)

        for i in xrange(img.shape[0]):
                for j in xrange(img.shape[1]):
                        if mask[i, j]==1:
                                newimg[i,j]=img[i,j]

        return np.mean(newimg)

def std_dev_pixel_value(img, mask):
        assert(np.arry_equal(img.shape, mask.shape)==True)

        newimg=np.zeros(img.shape)

        for i in xrange(img.shape[0]):
                for j in xrange(img.shape[1]):
                        if mask[i, j]==1:
                                newimg[i, j]=img[i, j]
        return np.std(newimg)

def effective_diameter(mask):
        area=np.sum(mask)
        d=math.sqrt(area/math.pi)
        return d

def degree_of_circularity(mask):
	centroids = ndimage.measurements.center_of_mass(mask)
	x = 0
	y = 0
	if type(centroids)==type([]):
		x = np.mean(np.array([pt[0] for pt in centroids]))
		y = np.mean(np.array([pt[1] for pt in centroids]))
	else:
		x = centroids[0]
		y = centroids[1]
	
	diameter = effective_diameter(mask)
	print diameter
	MatX = np.matlib.repmat(np.array([e-y for e in  xrange(mask.shape[1])]), mask.shape[0], 1)
	MatY = np.matlib.repmat(np.transpose(np.array([e-x for e in xrange(mask.shape[0])])), 1, mask.shape[1])
	#MatY = np.empty((1, mask.shape[1])).astype(np.float)

	#for i in xrange(mask.shape[1]):
	#	MatX=np.vstack((MatX, [e-x for e in range(mask.shape[1])]))

        #for i in xrange(mask.shape[1]):
         #       MatY=np.vstack((MatY, [e-y for e in range(mask.shape[0])]))

	Z=np.zeros(mask.shape)
	k=0
	print type(MatY)
	print MatY.shape
	for i in xrange(Z.shape[0]):
		for j in xrange(Z.shape[1]):
			Z[i, j]=MatX[i, j]*MatX[i, j]+MatY[0, k]*MatY[0, k]
			k=k+1
	C=np.zeros(mask.shape)
	
	for i in xrange(Z.shape[0]):
		for j in xrange(Z.shape[1]):
			if Z[i, j]<=(diameter*diameter)/4:
				C[i, j] = 1
 	nodule_area = np.mean(mask)
	overlapping_nodule_area = np.sum(np.logical_and(rasterize(C), mask).astype(int))
	print nodule_area	
	return overlapping_nodule_area/nodule_area

if __name__=='__main__':
	import sys
	img=get_outline_mask(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))
	#print np.array_equal(img.astype(np.uint8), rasterize(img))
	print degree_of_circularity(rasterize(img))
